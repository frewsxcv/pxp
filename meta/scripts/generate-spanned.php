<?php

use Illuminate\Support\Arr;
use Symfony\Component\Yaml\Yaml;

require_once __DIR__ . '/../vendor/autoload.php';

class SpannedGenerator
{
    /** @var array<string, array | string> */
    private array $ast;

    public function __construct()
    {
        $this->ast = Yaml::parseFile(__DIR__ . '/../../crates/pxp-ast/meta/ast.yaml');
    }

    public function generate(): string
    {
        $output = <<<'RUST'
        // This file is generated by meta/scripts/generate-spanned.php.
        // Do not make modifications to this file directly.

        use pxp_span::{Span, Spanned};
        use crate::generated::*;


        RUST;

        foreach ($this->ast as $node => $structure) {
            if (is_string($structure)) {
                continue;
            }

            $output .= "impl Spanned for {$node} {\n";
            $output .= "    fn span(&self) -> Span {\n";

            if (is_array($structure) && isset($structure['as']) && $structure['as'] === 'Enum') {
                $output .= $this->generateSpannedForEnum($node, $structure);
            } else {
                $output .= $this->generateSpannedForStruct($node, $structure);
            }

            $output .= "    }\n";
            $output .= "}\n\n";
        }

        return $output;
    }

    private function generateSpannedForEnum(string $node, array $structure): string
    {
        $output = "match self {\n";

        foreach ($structure as $variant => $type) {
            if ($variant === 'as' || $variant === 'derive') {
                continue;
            }

            if ($type === '') {
                $output .= "{$node}::{$variant} => Span::default(),\n";
                continue;
            }

            if (is_string($type)) {
                $output .= "{$node}::{$variant}(inner) => inner.span(),\n";
                continue;
            }
        }

        return $output . "}\n";
    }

    private function generateSpannedForStruct(string $node, array $structure): string
    {
        if (isset($structure['span'])) {
            return 'self.span';
        }

        if (count($structure) === 0) {
            return 'Span::default()';
        }

        if (count($structure) === 1) {
            if (Arr::first($structure) === 'Token') {
                return sprintf('self.%s.span', array_key_first($structure));
            } else {
                return sprintf('self.%s.span()', array_key_first($structure));
            }
        }

        $start = $this->findSpannedField($structure);
        $end = $this->findLastSpannedField($structure);

        if ($start === $end) {
            return sprintf('self.%s.span()', $start);
        }

        $output = '';

        $output .= sprintf("let start = self.%s.span();\n", $start);
        $output .= sprintf("let end = self.%s.span();\n", $end);
        $output .= "start.merge(&end)\n";

        return $output;
    }

    private function findSpannedField(array $structure, bool $withOption = true): string
    {
        foreach ($structure as $field => $type) {
            if ($type === 'Span' || ($withOption && $type === 'Option<Span>')) {
                return $field;
            }
        }

        return array_key_first(array_filter($structure, fn (string $key) => !in_array($key, ['as', 'derive']), ARRAY_FILTER_USE_KEY));
    }

    private function findLastSpannedField(array $structure, bool $withOption = true): string
    {
        $fields = array_keys($structure);

        for ($i = count($fields) - 1; $i >= 0; $i--) {
            $field = $fields[$i];

            if ($structure[$field] === 'Span' || ($withOption && $structure[$field] === 'Option<Span>')) {
                return $field;
            }
        }

        return array_key_last(array_filter($structure, fn (string $key) => !in_array($key, ['as', 'derive']), ARRAY_FILTER_USE_KEY));
    }
}

$generator = new SpannedGenerator();

file_put_contents(__DIR__ . '/../../crates/pxp-ast/src/spanned.rs', $generator->generate());

echo "Generated `Spanned` implementations.\n";