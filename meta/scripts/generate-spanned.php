<?php

use Illuminate\Support\Arr;
use Symfony\Component\Yaml\Yaml;

require_once __DIR__ . '/../vendor/autoload.php';

class SpannedGenerator
{
    /** @var array<string, array | string> */
    private array $ast;

    public function __construct()
    {
        $this->ast = Yaml::parseFile(__DIR__ . '/../../crates/pxp-ast/meta/ast.yaml');
    }

    public function generate(): string
    {
        $output = <<<'RUST'
        // This file is generated by meta/scripts/generate-spanned.php.
        // Do not make modifications to this file directly.
        #![allow(unused)]

        use pxp_span::{Span, Spanned};
        use crate::generated::*;


        RUST;

        foreach ($this->ast as $node => $structure) {
            if (is_string($structure)) {
                continue;
            }

            $output .= "impl Spanned for {$node} {\n";
            $output .= "    fn span(&self) -> Span {\n";

            if (is_array($structure) && isset($structure['as']) && $structure['as'] === 'Enum') {
                $output .= $this->generateSpannedForEnum($node, $structure);
            } else {
                $output .= $this->generateSpannedForStruct($node, $structure);
            }

            $output .= "    }\n";
            $output .= "}\n\n";
        }

        return $output;
    }

    private function generateSpannedForEnum(string $node, array $structure): string
    {
        $output = "match self {\n";

        foreach ($structure as $variant => $type) {
            if ($variant === 'as' || $variant === 'derive') {
                continue;
            }

            if ($type === '') {
                $output .= "{$node}::{$variant} => Span::default(),\n";
                continue;
            }

            if (is_string($type)) {
                $output .= "{$node}::{$variant}(inner) => inner.span(),\n";
                continue;
            }

            if (is_array($type)) {
                $output .= "{$node}::{$variant} { ";
                
                foreach (array_keys($type) as $subfield) {
                    $output .= "{$subfield}, ";
                }

                $output .= "} => {\n";

                if (isset($type['span'])) {
                    $output .= 'self.span';
                }

                if (count($type) === 0) {
                    $output .= 'Span::default()';
                }

                $fields = array_filter($type, fn ($value, $key) => $this->isSpannedType($value) && !in_array($key, ['as', 'derive']), ARRAY_FILTER_USE_BOTH);

                if (count($fields) === 1) {
                    if (Arr::first($fields) === 'Token') {
                        $output .= sprintf('%s.span', array_key_first($fields));
                    } elseif ($this->isSpannedType(Arr::first($fields))) {
                        $output .= sprintf('%s.span()', array_key_first($fields));
                    } else {
                        $output .= 'Span::default()';
                    }

                    goto close_block;
                }

                $start = $this->findSpannedField($fields);
                $end = $this->findLastSpannedField($fields);

                if ($start === $end) {
                    $output .= sprintf('%s.span()', $start);
                    goto close_block;
                }

                if (!$this->isSpannedType($type[$start]) && !$this->isSpannedType($type[$end])) {
                    $output .= sprintf('Span::default()');
                    goto close_block;
                }

                if (!$this->isSpannedType($type[$start]) && $this->isSpannedType($type[$end])) {
                    $output .= sprintf('%s.span()', $end);
                    goto close_block;
                }

                $output .= sprintf("let start = %s.span();\n", $start);

                if ($fields[$end] === '(Span, Span)') {
                    $output .= sprintf("let end = %s.1.span();\n", $end);
                } else {
                    $output .= sprintf("let end = %s.span();\n", $end);
                }

                $output .= "start.merge(&end)\n";

                close_block:
                $output .= "}\n";
            }
        }

        return $output . "}\n";
    }

    private function generateSpannedForStruct(string $node, array $structure): string
    {
        if (isset($structure['span'])) {
            return 'self.span';
        }

        if (count($structure) === 0) {
            return 'Span::default()';
        }

        $fields = array_filter($structure, fn ($key) => !in_array($key, ['as', 'derive']), ARRAY_FILTER_USE_KEY);

        if (count($fields) === 1) {
            if (Arr::first($fields) === 'Token') {
                return sprintf('self.%s.span', array_key_first($fields));
            } elseif ($this->isSpannedType(Arr::first($fields))) {
                return sprintf('self.%s.span()', array_key_first($fields));
            } else {
                return 'Span::default()';
            }
        }

        $start = $this->findSpannedField($fields);
        $end = $this->findLastSpannedField($fields);

        if (!$this->isSpannedType($structure[$start]) && !$this->isSpannedType($structure[$end])) {
            return sprintf('Span::default()');
        }

        if ($start === $end) {
            return sprintf('self.%s.span()', $start);
        }

        if (!$this->isSpannedType($structure[$start]) && $this->isSpannedType($end)) {
            return sprintf('self.%s.span()', $end);
        }

        $output = '';

        $output .= sprintf("let start = self.%s.span();\n", $start);
        $output .= sprintf("let end = self.%s.span();\n", $end);
        $output .= "start.merge(&end)\n";

        return $output;
    }

    private function isSpannedType(string $type): bool
    {
        return !in_array($type, ['Symbol', 'bool', 'as', 'derive', 'NameQualification']);
    }

    private function findSpannedField(array $structure, bool $withOption = true): string
    {
        foreach ($structure as $field => $type) {
            if ($this->isSpannedType($type) || $type === 'Span' || ($withOption && $type === 'Option<Span>')) {
                return $field;
            }
        }

        return array_key_first(array_filter($structure, fn (string $key) => !in_array($key, ['as', 'derive']), ARRAY_FILTER_USE_KEY));
    }

    private function findLastSpannedField(array $structure, bool $withOption = true): string
    {
        $fields = array_keys($structure);

        for ($i = count($fields) - 1; $i >= 0; $i--) {
            $field = $fields[$i];

            if ($this->isSpannedType($structure[$field]) || $structure[$field] === 'Span' || ($withOption && $structure[$field] === 'Option<Span>')) {
                return $field;
            }
        }

        return array_key_last(array_filter($structure, fn (string $key) => !in_array($key, ['as', 'derive']), ARRAY_FILTER_USE_KEY));
    }
}

$generator = new SpannedGenerator();

file_put_contents(__DIR__ . '/../../crates/pxp-ast/src/spanned.rs', $generator->generate());

echo "Generated `Spanned` implementations.\n";