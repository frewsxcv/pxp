// This file is generated by meta/scripts/generate-spanned.php.
// Do not make modifications to this file directly.

use crate::generated::*;
use pxp_span::{Span, Spanned};

impl Spanned for Statement {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for StatementKind {
    fn span(&self) -> Span {
        match self {
            StatementKind::FullOpeningTag(inner) => inner.span(),
            StatementKind::ShortOpeningTag(inner) => inner.span(),
            StatementKind::EchoOpeningTag(inner) => inner.span(),
            StatementKind::ClosingTag(inner) => inner.span(),
            StatementKind::InlineHtml(inner) => inner.span(),
            StatementKind::Label(inner) => inner.span(),
            StatementKind::Goto(inner) => inner.span(),
            StatementKind::HaltCompiler(inner) => inner.span(),
            StatementKind::Static(inner) => inner.span(),
            StatementKind::DoWhile(inner) => inner.span(),
            StatementKind::While(inner) => inner.span(),
            StatementKind::For(inner) => inner.span(),
            StatementKind::Foreach(inner) => inner.span(),
            StatementKind::Break(inner) => inner.span(),
            StatementKind::Continue(inner) => inner.span(),
            StatementKind::Constant(inner) => inner.span(),
            StatementKind::Function(inner) => inner.span(),
            StatementKind::Class(inner) => inner.span(),
            StatementKind::Trait(inner) => inner.span(),
            StatementKind::Interface(inner) => inner.span(),
            StatementKind::If(inner) => inner.span(),
            StatementKind::Switch(inner) => inner.span(),
            StatementKind::Echo(inner) => inner.span(),
            StatementKind::Expression(inner) => inner.span(),
            StatementKind::Return(inner) => inner.span(),
            StatementKind::Namespace(inner) => inner.span(),
            StatementKind::Use(inner) => inner.span(),
            StatementKind::GroupUse(inner) => inner.span(),
            StatementKind::Comment(inner) => inner.span(),
            StatementKind::Try(inner) => inner.span(),
            StatementKind::UnitEnum(inner) => inner.span(),
            StatementKind::BackedEnum(inner) => inner.span(),
            StatementKind::Block(inner) => inner.span(),
            StatementKind::Global(inner) => inner.span(),
            StatementKind::Declare(inner) => inner.span(),
            StatementKind::Noop(inner) => inner.span(),
        }
    }
}

impl Spanned for Expression {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for ExpressionKind {
    fn span(&self) -> Span {
        match self {
            ExpressionKind::Missing => Span::default(),
            ExpressionKind::Eval(inner) => inner.span(),
            ExpressionKind::Empty(inner) => inner.span(),
            ExpressionKind::Die(inner) => inner.span(),
            ExpressionKind::Exit(inner) => inner.span(),
            ExpressionKind::Isset(inner) => inner.span(),
            ExpressionKind::Unset(inner) => inner.span(),
            ExpressionKind::Print(inner) => inner.span(),
            ExpressionKind::Literal(inner) => inner.span(),
            ExpressionKind::ArithmeticOperation(inner) => inner.span(),
            ExpressionKind::AssignmentOperation(inner) => inner.span(),
            ExpressionKind::BitwiseOperation(inner) => inner.span(),
            ExpressionKind::ComparisonOperation(inner) => inner.span(),
            ExpressionKind::LogicalOperation(inner) => inner.span(),
            ExpressionKind::Concat(inner) => inner.span(),
            ExpressionKind::Instanceof(inner) => inner.span(),
            ExpressionKind::Reference(inner) => inner.span(),
            ExpressionKind::Parenthesized(inner) => inner.span(),
            ExpressionKind::ErrorSuppress(inner) => inner.span(),
            ExpressionKind::Identifier(inner) => inner.span(),
            ExpressionKind::Variable(inner) => inner.span(),
            ExpressionKind::Include(inner) => inner.span(),
            ExpressionKind::IncludeOnce(inner) => inner.span(),
            ExpressionKind::Require(inner) => inner.span(),
            ExpressionKind::RequireOnce(inner) => inner.span(),
            ExpressionKind::FunctionCall(inner) => inner.span(),
            ExpressionKind::FunctionClosureCreation(inner) => inner.span(),
            ExpressionKind::MethodCall(inner) => inner.span(),
            ExpressionKind::MethodClosureCreation(inner) => inner.span(),
            ExpressionKind::NullsafeMethodCall(inner) => inner.span(),
            ExpressionKind::StaticMethodCall(inner) => inner.span(),
            ExpressionKind::StaticVariableMethodCall(inner) => inner.span(),
            ExpressionKind::StaticMethodClosureCreation(inner) => inner.span(),
            ExpressionKind::StaticVariableMethodClosureCreation(inner) => inner.span(),
            ExpressionKind::PropertyFetch(inner) => inner.span(),
            ExpressionKind::NullsafePropertyFetch(inner) => inner.span(),
            ExpressionKind::StaticPropertyFetch(inner) => inner.span(),
            ExpressionKind::ConstantFetch(inner) => inner.span(),
            ExpressionKind::Static => Span::default(),
            ExpressionKind::Self_ => Span::default(),
            ExpressionKind::Parent => Span::default(),
            ExpressionKind::ShortArray(inner) => inner.span(),
            ExpressionKind::Array(inner) => inner.span(),
            ExpressionKind::List(inner) => inner.span(),
            ExpressionKind::Closure(inner) => inner.span(),
            ExpressionKind::ArrowFunction(inner) => inner.span(),
            ExpressionKind::New(inner) => inner.span(),
            ExpressionKind::InterpolatedString(inner) => inner.span(),
            ExpressionKind::Heredoc(inner) => inner.span(),
            ExpressionKind::Nowdoc(inner) => inner.span(),
            ExpressionKind::ShellExec(inner) => inner.span(),
            ExpressionKind::AnonymousClass(inner) => inner.span(),
            ExpressionKind::Bool(inner) => inner.span(),
            ExpressionKind::ArrayIndex(inner) => inner.span(),
            ExpressionKind::Null => Span::default(),
            ExpressionKind::MagicConstant(inner) => inner.span(),
            ExpressionKind::ShortTernary(inner) => inner.span(),
            ExpressionKind::Ternary(inner) => inner.span(),
            ExpressionKind::Coalesce(inner) => inner.span(),
            ExpressionKind::Clone(inner) => inner.span(),
            ExpressionKind::Match(inner) => inner.span(),
            ExpressionKind::Throw(inner) => inner.span(),
            ExpressionKind::Yield(inner) => inner.span(),
            ExpressionKind::YieldFrom(inner) => inner.span(),
            ExpressionKind::Cast(inner) => inner.span(),
            ExpressionKind::Name(inner) => inner.span(),
            ExpressionKind::Noop => Span::default(),
        }
    }
}

impl Spanned for InlineHtmlStatement {
    fn span(&self) -> Span {
        self.html.span
    }
}

impl Spanned for FullOpeningTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for ShortOpeningTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for EchoOpeningTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for ClosingTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for ExpressionStatement {
    fn span(&self) -> Span {
        let start = self.expression.span();
        let end = self.ending.span();
        start.merge(&end)
    }
}

impl Spanned for GlobalStatement {
    fn span(&self) -> Span {
        self.global.span()
    }
}

impl Spanned for BlockStatement {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for CastKind {
    fn span(&self) -> Span {
        match self {
            CastKind::Int => Span::default(),
            CastKind::Bool => Span::default(),
            CastKind::Float => Span::default(),
            CastKind::String => Span::default(),
            CastKind::Array => Span::default(),
            CastKind::Object => Span::default(),
            CastKind::Unset => Span::default(),
        }
    }
}

impl Spanned for Case {
    fn span(&self) -> Span {
        let start = self.condition.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for Use {
    fn span(&self) -> Span {
        let start = self.name.span();
        let end = self.kind.span();
        start.merge(&end)
    }
}

impl Spanned for UseKind {
    fn span(&self) -> Span {
        match self {
            UseKind::Normal => Span::default(),
            UseKind::Function => Span::default(),
            UseKind::Const => Span::default(),
        }
    }
}

impl Spanned for EvalExpression {
    fn span(&self) -> Span {
        self.eval.span()
    }
}

impl Spanned for EmptyExpression {
    fn span(&self) -> Span {
        self.empty.span()
    }
}

impl Spanned for DieExpression {
    fn span(&self) -> Span {
        self.die.span()
    }
}

impl Spanned for ExitExpression {
    fn span(&self) -> Span {
        self.exit.span()
    }
}

impl Spanned for IssetExpression {
    fn span(&self) -> Span {
        self.isset.span()
    }
}

impl Spanned for UnsetExpression {
    fn span(&self) -> Span {
        self.unset.span()
    }
}

impl Spanned for PrintExpression {
    fn span(&self) -> Span {
        self.print.span()
    }
}

impl Spanned for ConcatExpression {
    fn span(&self) -> Span {
        self.dot.span()
    }
}

impl Spanned for InstanceofExpression {
    fn span(&self) -> Span {
        self.instanceof.span()
    }
}

impl Spanned for ReferenceExpression {
    fn span(&self) -> Span {
        self.ampersand.span()
    }
}

impl Spanned for ParenthesizedExpression {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for ErrorSuppressExpression {
    fn span(&self) -> Span {
        self.at.span()
    }
}

impl Spanned for IncludeExpression {
    fn span(&self) -> Span {
        self.include.span()
    }
}

impl Spanned for IncludeOnceExpression {
    fn span(&self) -> Span {
        self.include_once.span()
    }
}

impl Spanned for RequireExpression {
    fn span(&self) -> Span {
        self.require.span()
    }
}

impl Spanned for RequireOnceExpression {
    fn span(&self) -> Span {
        self.require_once.span()
    }
}

impl Spanned for FunctionCallExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.arguments.span();
        start.merge(&end)
    }
}

impl Spanned for FunctionClosureCreationExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.placeholder.span();
        start.merge(&end)
    }
}

impl Spanned for MethodCallExpression {
    fn span(&self) -> Span {
        self.arrow.span()
    }
}

impl Spanned for MethodClosureCreationExpression {
    fn span(&self) -> Span {
        self.arrow.span()
    }
}

impl Spanned for NullsafeMethodCallExpression {
    fn span(&self) -> Span {
        self.question_arrow.span()
    }
}

impl Spanned for StaticMethodCallExpression {
    fn span(&self) -> Span {
        self.double_colon.span()
    }
}

impl Spanned for StaticVariableMethodCallExpression {
    fn span(&self) -> Span {
        self.double_colon.span()
    }
}

impl Spanned for StaticMethodClosureCreationExpression {
    fn span(&self) -> Span {
        self.double_colon.span()
    }
}

impl Spanned for StaticVariableMethodClosureCreationExpression {
    fn span(&self) -> Span {
        self.double_colon.span()
    }
}

impl Spanned for PropertyFetchExpression {
    fn span(&self) -> Span {
        self.arrow.span()
    }
}

impl Spanned for NullsafePropertyFetchExpression {
    fn span(&self) -> Span {
        self.question_arrow.span()
    }
}

impl Spanned for StaticPropertyFetchExpression {
    fn span(&self) -> Span {
        self.double_colon.span()
    }
}

impl Spanned for ConstantFetchExpression {
    fn span(&self) -> Span {
        self.double_colon.span()
    }
}

impl Spanned for ShortArrayExpression {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for ArrayExpression {
    fn span(&self) -> Span {
        let start = self.array.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for ListExpression {
    fn span(&self) -> Span {
        let start = self.list.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for NewExpression {
    fn span(&self) -> Span {
        self.new.span()
    }
}

impl Spanned for InterpolatedStringExpression {
    fn span(&self) -> Span {
        self.parts.span()
    }
}

impl Spanned for HeredocExpression {
    fn span(&self) -> Span {
        let start = self.label.span();
        let end = self.parts.span();
        start.merge(&end)
    }
}

impl Spanned for NowdocExpression {
    fn span(&self) -> Span {
        let start = self.label.span();
        let end = self.value.span();
        start.merge(&end)
    }
}

impl Spanned for ShellExecExpression {
    fn span(&self) -> Span {
        self.parts.span()
    }
}

impl Spanned for BoolExpression {
    fn span(&self) -> Span {
        self.value.span()
    }
}

impl Spanned for ArrayIndexExpression {
    fn span(&self) -> Span {
        let start = self.left_bracket.span();
        let end = self.right_bracket.span();
        start.merge(&end)
    }
}

impl Spanned for ShortTernaryExpression {
    fn span(&self) -> Span {
        self.question_colon.span()
    }
}

impl Spanned for TernaryExpression {
    fn span(&self) -> Span {
        let start = self.question.span();
        let end = self.colon.span();
        start.merge(&end)
    }
}

impl Spanned for CoalesceExpression {
    fn span(&self) -> Span {
        self.double_question.span()
    }
}

impl Spanned for CloneExpression {
    fn span(&self) -> Span {
        self.target.span()
    }
}

impl Spanned for MatchExpression {
    fn span(&self) -> Span {
        let start = self.keyword.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for ThrowExpression {
    fn span(&self) -> Span {
        self.value.span()
    }
}

impl Spanned for YieldExpression {
    fn span(&self) -> Span {
        let start = self.key.span();
        let end = self.value.span();
        start.merge(&end)
    }
}

impl Spanned for YieldFromExpression {
    fn span(&self) -> Span {
        self.value.span()
    }
}

impl Spanned for CastExpression {
    fn span(&self) -> Span {
        self.cast.span()
    }
}

impl Spanned for DefaultMatchArm {
    fn span(&self) -> Span {
        let start = self.keyword.span();
        let end = self.double_arrow.span();
        start.merge(&end)
    }
}

impl Spanned for MatchArm {
    fn span(&self) -> Span {
        self.arrow.span()
    }
}

impl Spanned for MagicConstantExpression {
    fn span(&self) -> Span {
        match self {
            MagicConstantExpression::Directory(inner) => inner.span(),
            MagicConstantExpression::File(inner) => inner.span(),
            MagicConstantExpression::Line(inner) => inner.span(),
            MagicConstantExpression::Function(inner) => inner.span(),
            MagicConstantExpression::Class(inner) => inner.span(),
            MagicConstantExpression::Method(inner) => inner.span(),
            MagicConstantExpression::Namespace(inner) => inner.span(),
            MagicConstantExpression::Trait(inner) => inner.span(),
            MagicConstantExpression::CompilerHaltOffset(inner) => inner.span(),
        }
    }
}

impl Spanned for StringPart {
    fn span(&self) -> Span {
        match self {
            StringPart::Literal(inner) => inner.span(),
            StringPart::Expression(inner) => inner.span(),
        }
    }
}

impl Spanned for LiteralStringPart {
    fn span(&self) -> Span {
        self.value.span()
    }
}

impl Spanned for ExpressionStringPart {
    fn span(&self) -> Span {
        self.expression.span()
    }
}

impl Spanned for ArrayItem {
    fn span(&self) -> Span {
        match self {
            ArrayItem::Skipped => Span::default(),
        }
    }
}

impl Spanned for ListEntry {
    fn span(&self) -> Span {
        match self {
            ListEntry::Skipped => Span::default(),
        }
    }
}

impl Spanned for PositionalArgument {
    fn span(&self) -> Span {
        self.ellipsis.span()
    }
}

impl Spanned for NamedArgument {
    fn span(&self) -> Span {
        let start = self.colon.span();
        let end = self.ellipsis.span();
        start.merge(&end)
    }
}

impl Spanned for Argument {
    fn span(&self) -> Span {
        match self {
            Argument::Positional(inner) => inner.span(),
            Argument::Named(inner) => inner.span(),
        }
    }
}

impl Spanned for ArgumentList {
    fn span(&self) -> Span {
        let start = self.left_parenthesis.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for SingleArgument {
    fn span(&self) -> Span {
        let start = self.left_parenthesis.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for ArgumentPlaceholder {
    fn span(&self) -> Span {
        let start = self.left_parenthesis.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for Attribute {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for AttributeGroup {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for ClassBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for ClassStatement {
    fn span(&self) -> Span {
        self.class.span()
    }
}

impl Spanned for AnonymousClassBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for AnonymousClassExpression {
    fn span(&self) -> Span {
        self.class.span()
    }
}

impl Spanned for ClassExtends {
    fn span(&self) -> Span {
        self.extends.span()
    }
}

impl Spanned for ClassImplements {
    fn span(&self) -> Span {
        self.implements.span()
    }
}

impl Spanned for ClassishMember {
    fn span(&self) -> Span {
        match self {
            ClassishMember::Constant(inner) => inner.span(),
            ClassishMember::TraitUsage(inner) => inner.span(),
            ClassishMember::Property(inner) => inner.span(),
            ClassishMember::VariableProperty(inner) => inner.span(),
            ClassishMember::AbstractMethod(inner) => inner.span(),
            ClassishMember::AbstractConstructor(inner) => inner.span(),
            ClassishMember::ConcreteMethod(inner) => inner.span(),
            ClassishMember::ConcreteConstructor(inner) => inner.span(),
        }
    }
}

impl Spanned for ConstantEntry {
    fn span(&self) -> Span {
        self.equals.span()
    }
}

impl Spanned for ClassishConstantEntry {
    fn span(&self) -> Span {
        self.equals.span()
    }
}

impl Spanned for ConstantStatement {
    fn span(&self) -> Span {
        let start = self.r#const.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for ClassishConstant {
    fn span(&self) -> Span {
        let start = self.r#const.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for IfStatement {
    fn span(&self) -> Span {
        let start = self.r#if.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for IfStatementBody {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for IfStatementElseIf {
    fn span(&self) -> Span {
        let start = self.elseif.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for IfStatementElse {
    fn span(&self) -> Span {
        self.r#else.span()
    }
}

impl Spanned for IfStatementElseIfBlock {
    fn span(&self) -> Span {
        let start = self.elseif.span();
        let end = self.colon.span();
        start.merge(&end)
    }
}

impl Spanned for IfStatementElseBlock {
    fn span(&self) -> Span {
        let start = self.r#else.span();
        let end = self.colon.span();
        start.merge(&end)
    }
}

impl Spanned for DataType {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for DeclareEntry {
    fn span(&self) -> Span {
        self.equals.span()
    }
}

impl Spanned for DeclareEntryGroup {
    fn span(&self) -> Span {
        let start = self.left_parenthesis.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for DeclareBody {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for DeclareStatement {
    fn span(&self) -> Span {
        self.declare.span()
    }
}

impl Spanned for UnitEnumCase {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for UnitEnumMember {
    fn span(&self) -> Span {
        match self {
            UnitEnumMember::Case(inner) => inner.span(),
            UnitEnumMember::Classish(inner) => inner.span(),
        }
    }
}

impl Spanned for UnitEnumBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for UnitEnumStatement {
    fn span(&self) -> Span {
        self.r#enum.span()
    }
}

impl Spanned for BackedEnumCase {
    fn span(&self) -> Span {
        let start = self.case.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for BackedEnumMember {
    fn span(&self) -> Span {
        match self {
            BackedEnumMember::Case(inner) => inner.span(),
            BackedEnumMember::Classish(inner) => inner.span(),
        }
    }
}

impl Spanned for BackedEnumBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for BackedEnumStatement {
    fn span(&self) -> Span {
        self.r#enum.span()
    }
}

impl Spanned for ReturnType {
    fn span(&self) -> Span {
        self.colon.span()
    }
}

impl Spanned for FunctionParameter {
    fn span(&self) -> Span {
        let start = self.ellipsis.span();
        let end = self.ampersand.span();
        start.merge(&end)
    }
}

impl Spanned for FunctionParameterList {
    fn span(&self) -> Span {
        let start = self.left_parenthesis.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for FunctionBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for FunctionStatement {
    fn span(&self) -> Span {
        let start = self.function.span();
        let end = self.ampersand.span();
        start.merge(&end)
    }
}

impl Spanned for ClosureUseVariable {
    fn span(&self) -> Span {
        self.ampersand.span()
    }
}

impl Spanned for ClosureUse {
    fn span(&self) -> Span {
        let start = self.r#use.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for ClosureExpression {
    fn span(&self) -> Span {
        let start = self.r#static.span();
        let end = self.ampersand.span();
        start.merge(&end)
    }
}

impl Spanned for ArrowFunctionExpression {
    fn span(&self) -> Span {
        let start = self.r#static.span();
        let end = self.double_arrow.span();
        start.merge(&end)
    }
}

impl Spanned for ConstructorParameter {
    fn span(&self) -> Span {
        let start = self.ampersand.span();
        let end = self.ellipsis.span();
        start.merge(&end)
    }
}

impl Spanned for ConstructorParameterList {
    fn span(&self) -> Span {
        let start = self.left_parenthesis.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for AbstractConstructor {
    fn span(&self) -> Span {
        let start = self.function.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for ConcreteConstructor {
    fn span(&self) -> Span {
        let start = self.function.span();
        let end = self.ampersand.span();
        start.merge(&end)
    }
}

impl Spanned for AbstractMethod {
    fn span(&self) -> Span {
        let start = self.function.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for ConcreteMethod {
    fn span(&self) -> Span {
        let start = self.function.span();
        let end = self.ampersand.span();
        start.merge(&end)
    }
}

impl Spanned for MethodBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for LabelStatement {
    fn span(&self) -> Span {
        self.colon.span()
    }
}

impl Spanned for GotoStatement {
    fn span(&self) -> Span {
        let start = self.keyword.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for Identifier {
    fn span(&self) -> Span {
        match self {
            Identifier::SimpleIdentifier(inner) => inner.span(),
            Identifier::DynamicIdentifier(inner) => inner.span(),
        }
    }
}

impl Spanned for SimpleIdentifier {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for DynamicIdentifier {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for InterfaceExtends {
    fn span(&self) -> Span {
        self.extends.span()
    }
}

impl Spanned for InterfaceBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for InterfaceStatement {
    fn span(&self) -> Span {
        self.interface.span()
    }
}

impl Spanned for Literal {
    fn span(&self) -> Span {
        let start = self.kind.span();
        let end = self.token.span();
        start.merge(&end)
    }
}

impl Spanned for LiteralKind {
    fn span(&self) -> Span {
        match self {
            LiteralKind::Integer => Span::default(),
            LiteralKind::Float => Span::default(),
            LiteralKind::String => Span::default(),
            LiteralKind::Missing => Span::default(),
        }
    }
}

impl Spanned for ForeachStatement {
    fn span(&self) -> Span {
        let start = self.foreach.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for ForeachStatementIterator {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for ForeachStatementBody {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for ForStatement {
    fn span(&self) -> Span {
        let start = self.r#for.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for ForStatementIterator {
    fn span(&self) -> Span {
        let start = self.initializations_semicolon.span();
        let end = self.conditions_semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for ForStatementBody {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for DoWhileStatement {
    fn span(&self) -> Span {
        let start = self.r#do.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for WhileStatement {
    fn span(&self) -> Span {
        let start = self.r#while.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for WhileStatementBody {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for Level {
    fn span(&self) -> Span {
        match self {
            Level::Literal(inner) => inner.span(),
        }
    }
}

impl Spanned for BreakStatement {
    fn span(&self) -> Span {
        self.r#break.span()
    }
}

impl Spanned for ContinueStatement {
    fn span(&self) -> Span {
        self.r#continue.span()
    }
}

impl Spanned for VisibilityModifier {
    fn span(&self) -> Span {
        match self {
            VisibilityModifier::Public(inner) => inner.span(),
            VisibilityModifier::Protected(inner) => inner.span(),
            VisibilityModifier::Private(inner) => inner.span(),
        }
    }
}

impl Spanned for PromotedPropertyModifier {
    fn span(&self) -> Span {
        match self {
            PromotedPropertyModifier::Public(inner) => inner.span(),
            PromotedPropertyModifier::Protected(inner) => inner.span(),
            PromotedPropertyModifier::Private(inner) => inner.span(),
            PromotedPropertyModifier::Readonly(inner) => inner.span(),
        }
    }
}

impl Spanned for PromotedPropertyModifierGroup {
    fn span(&self) -> Span {
        self.modifiers.span()
    }
}

impl Spanned for PropertyModifier {
    fn span(&self) -> Span {
        match self {
            PropertyModifier::Public(inner) => inner.span(),
            PropertyModifier::Protected(inner) => inner.span(),
            PropertyModifier::Private(inner) => inner.span(),
            PropertyModifier::Static(inner) => inner.span(),
            PropertyModifier::Readonly(inner) => inner.span(),
        }
    }
}

impl Spanned for PropertyModifierGroup {
    fn span(&self) -> Span {
        self.modifiers.span()
    }
}

impl Spanned for MethodModifier {
    fn span(&self) -> Span {
        match self {
            MethodModifier::Public(inner) => inner.span(),
            MethodModifier::Protected(inner) => inner.span(),
            MethodModifier::Private(inner) => inner.span(),
            MethodModifier::Static(inner) => inner.span(),
            MethodModifier::Abstract(inner) => inner.span(),
            MethodModifier::Final(inner) => inner.span(),
        }
    }
}

impl Spanned for MethodModifierGroup {
    fn span(&self) -> Span {
        self.modifiers.span()
    }
}

impl Spanned for ClassModifier {
    fn span(&self) -> Span {
        match self {
            ClassModifier::Abstract(inner) => inner.span(),
            ClassModifier::Final(inner) => inner.span(),
            ClassModifier::Readonly(inner) => inner.span(),
        }
    }
}

impl Spanned for ClassModifierGroup {
    fn span(&self) -> Span {
        self.modifiers.span()
    }
}

impl Spanned for ConstantModifier {
    fn span(&self) -> Span {
        match self {
            ConstantModifier::Public(inner) => inner.span(),
            ConstantModifier::Protected(inner) => inner.span(),
            ConstantModifier::Private(inner) => inner.span(),
            ConstantModifier::Final(inner) => inner.span(),
        }
    }
}

impl Spanned for ConstantModifierGroup {
    fn span(&self) -> Span {
        self.modifiers.span()
    }
}

impl Spanned for UnbracedNamespace {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for BracedNamespace {
    fn span(&self) -> Span {
        self.namespace.span()
    }
}

impl Spanned for BracedNamespaceBody {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for NamespaceStatement {
    fn span(&self) -> Span {
        match self {
            NamespaceStatement::Unbraced(inner) => inner.span(),
            NamespaceStatement::Braced(inner) => inner.span(),
        }
    }
}

impl Spanned for ArithmeticOperationExpression {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for AssignmentOperationExpression {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for BitwiseOperationExpression {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for ComparisonOperationExpression {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for LogicalOperationExpression {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for Name {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for NameKind {
    fn span(&self) -> Span {
        match self {
            NameKind::Special(inner) => inner.span(),
            NameKind::Unresolved(inner) => inner.span(),
            NameKind::Resolved(inner) => inner.span(),
        }
    }
}

impl Spanned for SpecialName {
    fn span(&self) -> Span {
        let start = self.kind.span();
        let end = self.symbol.span();
        start.merge(&end)
    }
}

impl Spanned for SpecialNameKind {
    fn span(&self) -> Span {
        match self {
            SpecialNameKind::Self_ => Span::default(),
            SpecialNameKind::Parent => Span::default(),
            SpecialNameKind::Static => Span::default(),
        }
    }
}

impl Spanned for UnresolvedName {
    fn span(&self) -> Span {
        let start = self.symbol.span();
        let end = self.qualification.span();
        start.merge(&end)
    }
}

impl Spanned for ResolvedName {
    fn span(&self) -> Span {
        let start = self.resolved.span();
        let end = self.original.span();
        start.merge(&end)
    }
}

impl Spanned for Property {
    fn span(&self) -> Span {
        self.end.span()
    }
}

impl Spanned for VariableProperty {
    fn span(&self) -> Span {
        self.end.span()
    }
}

impl Spanned for PropertyEntry {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for TraitBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for TraitStatement {
    fn span(&self) -> Span {
        self.r#trait.span()
    }
}

impl Spanned for TraitUsage {
    fn span(&self) -> Span {
        self.r#use.span()
    }
}

impl Spanned for TraitUsageAdaptation {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for CatchType {
    fn span(&self) -> Span {
        match self {}
    }
}

impl Spanned for TryStatement {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for CatchBlock {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for FinallyBlock {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for Variable {
    fn span(&self) -> Span {
        match self {
            Variable::SimpleVariable(inner) => inner.span(),
            Variable::VariableVariable(inner) => inner.span(),
            Variable::BracedVariableVariable(inner) => inner.span(),
        }
    }
}

impl Spanned for SimpleVariable {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for VariableVariable {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for BracedVariableVariable {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for Ending {
    fn span(&self) -> Span {
        match self {
            Ending::Missing(inner) => inner.span(),
            Ending::Semicolon(inner) => inner.span(),
            Ending::CloseTag(inner) => inner.span(),
        }
    }
}

impl Spanned for StaticStatement {
    fn span(&self) -> Span {
        self.vars.span()
    }
}

impl Spanned for SwitchStatement {
    fn span(&self) -> Span {
        let start = self.switch.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for EchoStatement {
    fn span(&self) -> Span {
        self.echo.span()
    }
}

impl Spanned for ReturnStatement {
    fn span(&self) -> Span {
        self.r#return.span()
    }
}

impl Spanned for UseStatement {
    fn span(&self) -> Span {
        let start = self.kind.span();
        let end = self.uses.span();
        start.merge(&end)
    }
}

impl Spanned for GroupUseStatement {
    fn span(&self) -> Span {
        let start = self.prefix.span();
        let end = self.uses.span();
        start.merge(&end)
    }
}

impl Spanned for HaltCompilerStatement {
    fn span(&self) -> Span {
        self.content.span()
    }
}

impl Spanned for StaticVar {
    fn span(&self) -> Span {
        let start = self.var.span();
        let end = self.default.span();
        start.merge(&end)
    }
}
