// This file is generated by meta/scripts/generate-spanned.php.
// Do not make modifications to this file directly.
#![allow(unused)]

use crate::generated::*;
use pxp_span::{Span, Spanned};

impl Spanned for Statement {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for StatementKind {
    fn span(&self) -> Span {
        match self {
            StatementKind::FullOpeningTag(inner) => inner.span(),
            StatementKind::ShortOpeningTag(inner) => inner.span(),
            StatementKind::EchoOpeningTag(inner) => inner.span(),
            StatementKind::ClosingTag(inner) => inner.span(),
            StatementKind::InlineHtml(inner) => inner.span(),
            StatementKind::Label(inner) => inner.span(),
            StatementKind::Goto(inner) => inner.span(),
            StatementKind::HaltCompiler(inner) => inner.span(),
            StatementKind::Static(inner) => inner.span(),
            StatementKind::DoWhile(inner) => inner.span(),
            StatementKind::While(inner) => inner.span(),
            StatementKind::For(inner) => inner.span(),
            StatementKind::Foreach(inner) => inner.span(),
            StatementKind::Break(inner) => inner.span(),
            StatementKind::Continue(inner) => inner.span(),
            StatementKind::Constant(inner) => inner.span(),
            StatementKind::Function(inner) => inner.span(),
            StatementKind::Class(inner) => inner.span(),
            StatementKind::Trait(inner) => inner.span(),
            StatementKind::Interface(inner) => inner.span(),
            StatementKind::If(inner) => inner.span(),
            StatementKind::Switch(inner) => inner.span(),
            StatementKind::Echo(inner) => inner.span(),
            StatementKind::Expression(inner) => inner.span(),
            StatementKind::Return(inner) => inner.span(),
            StatementKind::Namespace(inner) => inner.span(),
            StatementKind::Use(inner) => inner.span(),
            StatementKind::GroupUse(inner) => inner.span(),
            StatementKind::Comment(inner) => inner.span(),
            StatementKind::Try(inner) => inner.span(),
            StatementKind::UnitEnum(inner) => inner.span(),
            StatementKind::BackedEnum(inner) => inner.span(),
            StatementKind::Block(inner) => inner.span(),
            StatementKind::Global(inner) => inner.span(),
            StatementKind::Declare(inner) => inner.span(),
            StatementKind::Noop(inner) => inner.span(),
        }
    }
}

impl Spanned for Expression {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for ExpressionKind {
    fn span(&self) -> Span {
        match self {
            ExpressionKind::Missing => Span::default(),
            ExpressionKind::Eval(inner) => inner.span(),
            ExpressionKind::Empty(inner) => inner.span(),
            ExpressionKind::Die(inner) => inner.span(),
            ExpressionKind::Exit(inner) => inner.span(),
            ExpressionKind::Isset(inner) => inner.span(),
            ExpressionKind::Unset(inner) => inner.span(),
            ExpressionKind::Print(inner) => inner.span(),
            ExpressionKind::Literal(inner) => inner.span(),
            ExpressionKind::ArithmeticOperation(inner) => inner.span(),
            ExpressionKind::AssignmentOperation(inner) => inner.span(),
            ExpressionKind::BitwiseOperation(inner) => inner.span(),
            ExpressionKind::ComparisonOperation(inner) => inner.span(),
            ExpressionKind::LogicalOperation(inner) => inner.span(),
            ExpressionKind::Concat(inner) => inner.span(),
            ExpressionKind::Instanceof(inner) => inner.span(),
            ExpressionKind::Reference(inner) => inner.span(),
            ExpressionKind::Parenthesized(inner) => inner.span(),
            ExpressionKind::ErrorSuppress(inner) => inner.span(),
            ExpressionKind::Identifier(inner) => inner.span(),
            ExpressionKind::Variable(inner) => inner.span(),
            ExpressionKind::Include(inner) => inner.span(),
            ExpressionKind::IncludeOnce(inner) => inner.span(),
            ExpressionKind::Require(inner) => inner.span(),
            ExpressionKind::RequireOnce(inner) => inner.span(),
            ExpressionKind::FunctionCall(inner) => inner.span(),
            ExpressionKind::FunctionClosureCreation(inner) => inner.span(),
            ExpressionKind::MethodCall(inner) => inner.span(),
            ExpressionKind::MethodClosureCreation(inner) => inner.span(),
            ExpressionKind::NullsafeMethodCall(inner) => inner.span(),
            ExpressionKind::StaticMethodCall(inner) => inner.span(),
            ExpressionKind::StaticVariableMethodCall(inner) => inner.span(),
            ExpressionKind::StaticMethodClosureCreation(inner) => inner.span(),
            ExpressionKind::StaticVariableMethodClosureCreation(inner) => inner.span(),
            ExpressionKind::PropertyFetch(inner) => inner.span(),
            ExpressionKind::NullsafePropertyFetch(inner) => inner.span(),
            ExpressionKind::StaticPropertyFetch(inner) => inner.span(),
            ExpressionKind::ConstantFetch(inner) => inner.span(),
            ExpressionKind::Static => Span::default(),
            ExpressionKind::Self_ => Span::default(),
            ExpressionKind::Parent => Span::default(),
            ExpressionKind::ShortArray(inner) => inner.span(),
            ExpressionKind::Array(inner) => inner.span(),
            ExpressionKind::List(inner) => inner.span(),
            ExpressionKind::Closure(inner) => inner.span(),
            ExpressionKind::ArrowFunction(inner) => inner.span(),
            ExpressionKind::New(inner) => inner.span(),
            ExpressionKind::InterpolatedString(inner) => inner.span(),
            ExpressionKind::Heredoc(inner) => inner.span(),
            ExpressionKind::Nowdoc(inner) => inner.span(),
            ExpressionKind::ShellExec(inner) => inner.span(),
            ExpressionKind::AnonymousClass(inner) => inner.span(),
            ExpressionKind::Bool(inner) => inner.span(),
            ExpressionKind::ArrayIndex(inner) => inner.span(),
            ExpressionKind::Null => Span::default(),
            ExpressionKind::MagicConstant(inner) => inner.span(),
            ExpressionKind::ShortTernary(inner) => inner.span(),
            ExpressionKind::Ternary(inner) => inner.span(),
            ExpressionKind::Coalesce(inner) => inner.span(),
            ExpressionKind::Clone(inner) => inner.span(),
            ExpressionKind::Match(inner) => inner.span(),
            ExpressionKind::Throw(inner) => inner.span(),
            ExpressionKind::Yield(inner) => inner.span(),
            ExpressionKind::YieldFrom(inner) => inner.span(),
            ExpressionKind::Cast(inner) => inner.span(),
            ExpressionKind::Name(inner) => inner.span(),
            ExpressionKind::Noop => Span::default(),
        }
    }
}

impl Spanned for InlineHtmlStatement {
    fn span(&self) -> Span {
        self.html.span
    }
}

impl Spanned for FullOpeningTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for ShortOpeningTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for EchoOpeningTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for ClosingTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for ExpressionStatement {
    fn span(&self) -> Span {
        let start = self.expression.span();
        let end = self.ending.span();
        start.merge(&end)
    }
}

impl Spanned for GlobalStatement {
    fn span(&self) -> Span {
        let start = self.global.span();
        let end = self.variables.span();
        start.merge(&end)
    }
}

impl Spanned for BlockStatement {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for CastKind {
    fn span(&self) -> Span {
        match self {
            CastKind::Int => Span::default(),
            CastKind::Bool => Span::default(),
            CastKind::Float => Span::default(),
            CastKind::String => Span::default(),
            CastKind::Array => Span::default(),
            CastKind::Object => Span::default(),
            CastKind::Unset => Span::default(),
        }
    }
}

impl Spanned for Case {
    fn span(&self) -> Span {
        let start = self.condition.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for Use {
    fn span(&self) -> Span {
        let start = self.name.span();
        let end = self.kind.span();
        start.merge(&end)
    }
}

impl Spanned for UseKind {
    fn span(&self) -> Span {
        match self {
            UseKind::Normal => Span::default(),
            UseKind::Function => Span::default(),
            UseKind::Const => Span::default(),
        }
    }
}

impl Spanned for EvalExpression {
    fn span(&self) -> Span {
        let start = self.eval.span();
        let end = self.argument.span();
        start.merge(&end)
    }
}

impl Spanned for EmptyExpression {
    fn span(&self) -> Span {
        let start = self.empty.span();
        let end = self.argument.span();
        start.merge(&end)
    }
}

impl Spanned for DieExpression {
    fn span(&self) -> Span {
        let start = self.die.span();
        let end = self.argument.span();
        start.merge(&end)
    }
}

impl Spanned for ExitExpression {
    fn span(&self) -> Span {
        let start = self.exit.span();
        let end = self.argument.span();
        start.merge(&end)
    }
}

impl Spanned for IssetExpression {
    fn span(&self) -> Span {
        let start = self.isset.span();
        let end = self.arguments.span();
        start.merge(&end)
    }
}

impl Spanned for UnsetExpression {
    fn span(&self) -> Span {
        let start = self.unset.span();
        let end = self.arguments.span();
        start.merge(&end)
    }
}

impl Spanned for PrintExpression {
    fn span(&self) -> Span {
        let start = self.print.span();
        let end = self.argument.span();
        start.merge(&end)
    }
}

impl Spanned for ConcatExpression {
    fn span(&self) -> Span {
        let start = self.left.span();
        let end = self.right.span();
        start.merge(&end)
    }
}

impl Spanned for InstanceofExpression {
    fn span(&self) -> Span {
        let start = self.left.span();
        let end = self.right.span();
        start.merge(&end)
    }
}

impl Spanned for ReferenceExpression {
    fn span(&self) -> Span {
        let start = self.ampersand.span();
        let end = self.right.span();
        start.merge(&end)
    }
}

impl Spanned for ParenthesizedExpression {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for ErrorSuppressExpression {
    fn span(&self) -> Span {
        let start = self.at.span();
        let end = self.expr.span();
        start.merge(&end)
    }
}

impl Spanned for IncludeExpression {
    fn span(&self) -> Span {
        let start = self.include.span();
        let end = self.path.span();
        start.merge(&end)
    }
}

impl Spanned for IncludeOnceExpression {
    fn span(&self) -> Span {
        let start = self.include_once.span();
        let end = self.path.span();
        start.merge(&end)
    }
}

impl Spanned for RequireExpression {
    fn span(&self) -> Span {
        let start = self.require.span();
        let end = self.path.span();
        start.merge(&end)
    }
}

impl Spanned for RequireOnceExpression {
    fn span(&self) -> Span {
        let start = self.require_once.span();
        let end = self.path.span();
        start.merge(&end)
    }
}

impl Spanned for FunctionCallExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.arguments.span();
        start.merge(&end)
    }
}

impl Spanned for FunctionClosureCreationExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.placeholder.span();
        start.merge(&end)
    }
}

impl Spanned for MethodCallExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.arguments.span();
        start.merge(&end)
    }
}

impl Spanned for MethodClosureCreationExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.placeholder.span();
        start.merge(&end)
    }
}

impl Spanned for NullsafeMethodCallExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.arguments.span();
        start.merge(&end)
    }
}

impl Spanned for StaticMethodCallExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.arguments.span();
        start.merge(&end)
    }
}

impl Spanned for StaticVariableMethodCallExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.arguments.span();
        start.merge(&end)
    }
}

impl Spanned for StaticMethodClosureCreationExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.placeholder.span();
        start.merge(&end)
    }
}

impl Spanned for StaticVariableMethodClosureCreationExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.placeholder.span();
        start.merge(&end)
    }
}

impl Spanned for PropertyFetchExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.property.span();
        start.merge(&end)
    }
}

impl Spanned for NullsafePropertyFetchExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.property.span();
        start.merge(&end)
    }
}

impl Spanned for StaticPropertyFetchExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.property.span();
        start.merge(&end)
    }
}

impl Spanned for ConstantFetchExpression {
    fn span(&self) -> Span {
        let start = self.target.span();
        let end = self.constant.span();
        start.merge(&end)
    }
}

impl Spanned for ShortArrayExpression {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for ArrayExpression {
    fn span(&self) -> Span {
        let start = self.array.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for ListExpression {
    fn span(&self) -> Span {
        let start = self.list.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for NewExpression {
    fn span(&self) -> Span {
        let start = self.new.span();
        let end = self.arguments.span();
        start.merge(&end)
    }
}

impl Spanned for InterpolatedStringExpression {
    fn span(&self) -> Span {
        self.parts.span()
    }
}

impl Spanned for HeredocExpression {
    fn span(&self) -> Span {
        self.parts.span()
    }
}

impl Spanned for NowdocExpression {
    fn span(&self) -> Span {
        let start = self.label.span();
        let end = self.value.span();
        start.merge(&end)
    }
}

impl Spanned for ShellExecExpression {
    fn span(&self) -> Span {
        self.parts.span()
    }
}

impl Spanned for BoolExpression {
    fn span(&self) -> Span {
        Span::default()
    }
}

impl Spanned for ArrayIndexExpression {
    fn span(&self) -> Span {
        let start = self.array.span();
        let end = self.right_bracket.span();
        start.merge(&end)
    }
}

impl Spanned for ShortTernaryExpression {
    fn span(&self) -> Span {
        let start = self.condition.span();
        let end = self.r#else.span();
        start.merge(&end)
    }
}

impl Spanned for TernaryExpression {
    fn span(&self) -> Span {
        let start = self.condition.span();
        let end = self.r#else.span();
        start.merge(&end)
    }
}

impl Spanned for CoalesceExpression {
    fn span(&self) -> Span {
        let start = self.lhs.span();
        let end = self.rhs.span();
        start.merge(&end)
    }
}

impl Spanned for CloneExpression {
    fn span(&self) -> Span {
        self.target.span()
    }
}

impl Spanned for MatchExpression {
    fn span(&self) -> Span {
        let start = self.keyword.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for ThrowExpression {
    fn span(&self) -> Span {
        self.value.span()
    }
}

impl Spanned for YieldExpression {
    fn span(&self) -> Span {
        let start = self.key.span();
        let end = self.value.span();
        start.merge(&end)
    }
}

impl Spanned for YieldFromExpression {
    fn span(&self) -> Span {
        self.value.span()
    }
}

impl Spanned for CastExpression {
    fn span(&self) -> Span {
        let start = self.cast.span();
        let end = self.value.span();
        start.merge(&end)
    }
}

impl Spanned for DefaultMatchArm {
    fn span(&self) -> Span {
        let start = self.keyword.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for MatchArm {
    fn span(&self) -> Span {
        let start = self.conditions.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for MagicConstantExpression {
    fn span(&self) -> Span {
        match self {
            MagicConstantExpression::Directory(inner) => inner.span(),
            MagicConstantExpression::File(inner) => inner.span(),
            MagicConstantExpression::Line(inner) => inner.span(),
            MagicConstantExpression::Function(inner) => inner.span(),
            MagicConstantExpression::Class(inner) => inner.span(),
            MagicConstantExpression::Method(inner) => inner.span(),
            MagicConstantExpression::Namespace(inner) => inner.span(),
            MagicConstantExpression::Trait(inner) => inner.span(),
            MagicConstantExpression::CompilerHaltOffset(inner) => inner.span(),
        }
    }
}

impl Spanned for StringPart {
    fn span(&self) -> Span {
        match self {
            StringPart::Literal(inner) => inner.span(),
            StringPart::Expression(inner) => inner.span(),
        }
    }
}

impl Spanned for LiteralStringPart {
    fn span(&self) -> Span {
        Span::default()
    }
}

impl Spanned for ExpressionStringPart {
    fn span(&self) -> Span {
        self.expression.span()
    }
}

impl Spanned for ArrayItem {
    fn span(&self) -> Span {
        match self {
            ArrayItem::Skipped => Span::default(),
            ArrayItem::Value { value } => value.span(),
            ArrayItem::ReferencedValue { ampersand, value } => {
                let start = ampersand.span();
                let end = value.span();
                start.merge(&end)
            }
            ArrayItem::SpreadValue { ellipsis, value } => {
                let start = ellipsis.span();
                let end = value.span();
                start.merge(&end)
            }
            ArrayItem::KeyValue {
                key,
                double_arrow,
                value,
            } => {
                let start = key.span();
                let end = value.span();
                start.merge(&end)
            }
            ArrayItem::ReferencedKeyValue {
                key,
                double_arrow,
                ampersand,
                value,
            } => {
                let start = key.span();
                let end = value.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for ListEntry {
    fn span(&self) -> Span {
        match self {
            ListEntry::Skipped => Span::default(),
            ListEntry::Value { value } => value.span(),
            ListEntry::KeyValue {
                key,
                double_arrow,
                value,
            } => {
                let start = key.span();
                let end = value.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for PositionalArgument {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.value.span();
        start.merge(&end)
    }
}

impl Spanned for NamedArgument {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.value.span();
        start.merge(&end)
    }
}

impl Spanned for Argument {
    fn span(&self) -> Span {
        match self {
            Argument::Positional(inner) => inner.span(),
            Argument::Named(inner) => inner.span(),
        }
    }
}

impl Spanned for ArgumentList {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for SingleArgument {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for ArgumentPlaceholder {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for Attribute {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for AttributeGroup {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for ClassBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for ClassStatement {
    fn span(&self) -> Span {
        let start = self.attributes.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for AnonymousClassBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for AnonymousClassExpression {
    fn span(&self) -> Span {
        let start = self.attributes.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for ClassExtends {
    fn span(&self) -> Span {
        let start = self.extends.span();
        let end = self.parent.span();
        start.merge(&end)
    }
}

impl Spanned for ClassImplements {
    fn span(&self) -> Span {
        let start = self.implements.span();
        let end = self.interfaces.span();
        start.merge(&end)
    }
}

impl Spanned for ClassishMember {
    fn span(&self) -> Span {
        match self {
            ClassishMember::Constant(inner) => inner.span(),
            ClassishMember::TraitUsage(inner) => inner.span(),
            ClassishMember::Property(inner) => inner.span(),
            ClassishMember::VariableProperty(inner) => inner.span(),
            ClassishMember::AbstractMethod(inner) => inner.span(),
            ClassishMember::AbstractConstructor(inner) => inner.span(),
            ClassishMember::ConcreteMethod(inner) => inner.span(),
            ClassishMember::ConcreteConstructor(inner) => inner.span(),
        }
    }
}

impl Spanned for ConstantEntry {
    fn span(&self) -> Span {
        let start = self.name.span();
        let end = self.value.span();
        start.merge(&end)
    }
}

impl Spanned for ClassishConstantEntry {
    fn span(&self) -> Span {
        let start = self.name.span();
        let end = self.value.span();
        start.merge(&end)
    }
}

impl Spanned for ConstantStatement {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for ClassishConstant {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for IfStatement {
    fn span(&self) -> Span {
        let start = self.r#if.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for IfStatementBody {
    fn span(&self) -> Span {
        match self {
            IfStatementBody::Statement {
                statement,
                elseifs,
                r#else,
            } => {
                let start = statement.span();
                let end = r#else.span();
                start.merge(&end)
            }
            IfStatementBody::Block {
                colon,
                statements,
                elseifs,
                r#else,
                endif,
                ending,
            } => {
                let start = colon.span();
                let end = ending.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for IfStatementElseIf {
    fn span(&self) -> Span {
        let start = self.elseif.span();
        let end = self.statement.span();
        start.merge(&end)
    }
}

impl Spanned for IfStatementElse {
    fn span(&self) -> Span {
        let start = self.r#else.span();
        let end = self.statement.span();
        start.merge(&end)
    }
}

impl Spanned for IfStatementElseIfBlock {
    fn span(&self) -> Span {
        let start = self.elseif.span();
        let end = self.statements.span();
        start.merge(&end)
    }
}

impl Spanned for IfStatementElseBlock {
    fn span(&self) -> Span {
        let start = self.r#else.span();
        let end = self.statements.span();
        start.merge(&end)
    }
}

impl Spanned for DataType {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for DeclareEntry {
    fn span(&self) -> Span {
        let start = self.key.span();
        let end = self.value.span();
        start.merge(&end)
    }
}

impl Spanned for DeclareEntryGroup {
    fn span(&self) -> Span {
        let start = self.left_parenthesis.span();
        let end = self.entries.span();
        start.merge(&end)
    }
}

impl Spanned for DeclareBody {
    fn span(&self) -> Span {
        match self {
            DeclareBody::Noop { semicolon } => semicolon.span(),
            DeclareBody::Braced {
                left_brace,
                statements,
                right_brace,
            } => {
                let start = left_brace.span();
                let end = right_brace.span();
                start.merge(&end)
            }
            DeclareBody::Expression {
                expression,
                semicolon,
            } => {
                let start = expression.span();
                let end = semicolon.span();
                start.merge(&end)
            }
            DeclareBody::Block {
                colon,
                statements,
                end,
            } => {
                let start = colon.span();
                let end = end.1.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for DeclareStatement {
    fn span(&self) -> Span {
        let start = self.declare.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for UnitEnumCase {
    fn span(&self) -> Span {
        let start = self.attributes.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for UnitEnumMember {
    fn span(&self) -> Span {
        match self {
            UnitEnumMember::Case(inner) => inner.span(),
            UnitEnumMember::Classish(inner) => inner.span(),
        }
    }
}

impl Spanned for UnitEnumBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for UnitEnumStatement {
    fn span(&self) -> Span {
        let start = self.attributes.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for BackedEnumCase {
    fn span(&self) -> Span {
        let start = self.attributes.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for BackedEnumMember {
    fn span(&self) -> Span {
        match self {
            BackedEnumMember::Case(inner) => inner.span(),
            BackedEnumMember::Classish(inner) => inner.span(),
        }
    }
}

impl Spanned for BackedEnumBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for BackedEnumStatement {
    fn span(&self) -> Span {
        let start = self.attributes.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for ReturnType {
    fn span(&self) -> Span {
        let start = self.colon.span();
        let end = self.data_type.span();
        start.merge(&end)
    }
}

impl Spanned for FunctionParameter {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.ampersand.span();
        start.merge(&end)
    }
}

impl Spanned for FunctionParameterList {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for FunctionBody {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for FunctionStatement {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for ClosureUseVariable {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.variable.span();
        start.merge(&end)
    }
}

impl Spanned for ClosureUse {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for ClosureExpression {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for ArrowFunctionExpression {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for ConstructorParameter {
    fn span(&self) -> Span {
        let start = self.attributes.span();
        let end = self.modifiers.span();
        start.merge(&end)
    }
}

impl Spanned for ConstructorParameterList {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.right_parenthesis.span();
        start.merge(&end)
    }
}

impl Spanned for AbstractConstructor {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for ConcreteConstructor {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for AbstractMethod {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for ConcreteMethod {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for MethodBody {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for LabelStatement {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.colon.span();
        start.merge(&end)
    }
}

impl Spanned for GotoStatement {
    fn span(&self) -> Span {
        let start = self.comments.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for Identifier {
    fn span(&self) -> Span {
        match self {
            Identifier::SimpleIdentifier(inner) => inner.span(),
            Identifier::DynamicIdentifier(inner) => inner.span(),
        }
    }
}

impl Spanned for SimpleIdentifier {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for DynamicIdentifier {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for InterfaceExtends {
    fn span(&self) -> Span {
        let start = self.extends.span();
        let end = self.parents.span();
        start.merge(&end)
    }
}

impl Spanned for InterfaceBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for InterfaceStatement {
    fn span(&self) -> Span {
        let start = self.attributes.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for Literal {
    fn span(&self) -> Span {
        let start = self.kind.span();
        let end = self.token.span();
        start.merge(&end)
    }
}

impl Spanned for LiteralKind {
    fn span(&self) -> Span {
        match self {
            LiteralKind::Integer => Span::default(),
            LiteralKind::Float => Span::default(),
            LiteralKind::String => Span::default(),
            LiteralKind::Missing => Span::default(),
        }
    }
}

impl Spanned for ForeachStatement {
    fn span(&self) -> Span {
        let start = self.foreach.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for ForeachStatementIterator {
    fn span(&self) -> Span {
        match self {
            ForeachStatementIterator::Value {
                expression,
                r#as,
                ampersand,
                value,
            } => {
                let start = expression.span();
                let end = value.span();
                start.merge(&end)
            }
            ForeachStatementIterator::KeyAndValue {
                expression,
                r#as,
                ampersand,
                key,
                double_arrow,
                value,
            } => {
                let start = expression.span();
                let end = value.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for ForeachStatementBody {
    fn span(&self) -> Span {
        match self {
            ForeachStatementBody::Statement { statement } => statement.span(),
            ForeachStatementBody::Block {
                colon,
                statements,
                endforeach,
                ending,
            } => {
                let start = colon.span();
                let end = ending.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for ForStatement {
    fn span(&self) -> Span {
        let start = self.r#for.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for ForStatementIterator {
    fn span(&self) -> Span {
        let start = self.initializations.span();
        let end = self.r#loop.span();
        start.merge(&end)
    }
}

impl Spanned for ForStatementBody {
    fn span(&self) -> Span {
        match self {
            ForStatementBody::Statement { statement } => statement.span(),
            ForStatementBody::Block {
                colon,
                statements,
                endfor,
                ending,
            } => {
                let start = colon.span();
                let end = ending.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for DoWhileStatement {
    fn span(&self) -> Span {
        let start = self.r#do.span();
        let end = self.semicolon.span();
        start.merge(&end)
    }
}

impl Spanned for WhileStatement {
    fn span(&self) -> Span {
        let start = self.r#while.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for WhileStatementBody {
    fn span(&self) -> Span {
        match self {
            WhileStatementBody::Statement { statement } => statement.span(),
            WhileStatementBody::Block {
                colon,
                statements,
                endwhile,
                ending,
            } => {
                let start = colon.span();
                let end = ending.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for Level {
    fn span(&self) -> Span {
        match self {
            Level::Literal(inner) => inner.span(),
            Level::Parenthesized {
                left_parenthesis,
                level,
                right_parenthesis,
            } => {
                let start = left_parenthesis.span();
                let end = right_parenthesis.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for BreakStatement {
    fn span(&self) -> Span {
        let start = self.r#break.span();
        let end = self.ending.span();
        start.merge(&end)
    }
}

impl Spanned for ContinueStatement {
    fn span(&self) -> Span {
        let start = self.r#continue.span();
        let end = self.ending.span();
        start.merge(&end)
    }
}

impl Spanned for VisibilityModifier {
    fn span(&self) -> Span {
        match self {
            VisibilityModifier::Public(inner) => inner.span(),
            VisibilityModifier::Protected(inner) => inner.span(),
            VisibilityModifier::Private(inner) => inner.span(),
        }
    }
}

impl Spanned for PromotedPropertyModifier {
    fn span(&self) -> Span {
        match self {
            PromotedPropertyModifier::Public(inner) => inner.span(),
            PromotedPropertyModifier::Protected(inner) => inner.span(),
            PromotedPropertyModifier::Private(inner) => inner.span(),
            PromotedPropertyModifier::Readonly(inner) => inner.span(),
        }
    }
}

impl Spanned for PromotedPropertyModifierGroup {
    fn span(&self) -> Span {
        self.modifiers.span()
    }
}

impl Spanned for PropertyModifier {
    fn span(&self) -> Span {
        match self {
            PropertyModifier::Public(inner) => inner.span(),
            PropertyModifier::Protected(inner) => inner.span(),
            PropertyModifier::Private(inner) => inner.span(),
            PropertyModifier::Static(inner) => inner.span(),
            PropertyModifier::Readonly(inner) => inner.span(),
        }
    }
}

impl Spanned for PropertyModifierGroup {
    fn span(&self) -> Span {
        self.modifiers.span()
    }
}

impl Spanned for MethodModifier {
    fn span(&self) -> Span {
        match self {
            MethodModifier::Public(inner) => inner.span(),
            MethodModifier::Protected(inner) => inner.span(),
            MethodModifier::Private(inner) => inner.span(),
            MethodModifier::Static(inner) => inner.span(),
            MethodModifier::Abstract(inner) => inner.span(),
            MethodModifier::Final(inner) => inner.span(),
        }
    }
}

impl Spanned for MethodModifierGroup {
    fn span(&self) -> Span {
        self.modifiers.span()
    }
}

impl Spanned for ClassModifier {
    fn span(&self) -> Span {
        match self {
            ClassModifier::Abstract(inner) => inner.span(),
            ClassModifier::Final(inner) => inner.span(),
            ClassModifier::Readonly(inner) => inner.span(),
        }
    }
}

impl Spanned for ClassModifierGroup {
    fn span(&self) -> Span {
        self.modifiers.span()
    }
}

impl Spanned for ConstantModifier {
    fn span(&self) -> Span {
        match self {
            ConstantModifier::Public(inner) => inner.span(),
            ConstantModifier::Protected(inner) => inner.span(),
            ConstantModifier::Private(inner) => inner.span(),
            ConstantModifier::Final(inner) => inner.span(),
        }
    }
}

impl Spanned for ConstantModifierGroup {
    fn span(&self) -> Span {
        self.modifiers.span()
    }
}

impl Spanned for UnbracedNamespace {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.statements.span();
        start.merge(&end)
    }
}

impl Spanned for BracedNamespace {
    fn span(&self) -> Span {
        let start = self.namespace.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for BracedNamespaceBody {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.statements.span();
        start.merge(&end)
    }
}

impl Spanned for NamespaceStatement {
    fn span(&self) -> Span {
        match self {
            NamespaceStatement::Unbraced(inner) => inner.span(),
            NamespaceStatement::Braced(inner) => inner.span(),
        }
    }
}

impl Spanned for ArithmeticOperationExpression {
    fn span(&self) -> Span {
        match self {
            ArithmeticOperationExpression::Addition { left, plus, right } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ArithmeticOperationExpression::Subtraction { left, minus, right } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ArithmeticOperationExpression::Multiplication {
                left,
                asterisk,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ArithmeticOperationExpression::Division { left, slash, right } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ArithmeticOperationExpression::Modulo {
                left,
                percent,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ArithmeticOperationExpression::Exponentiation { left, pow, right } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ArithmeticOperationExpression::Negative { minus, right } => {
                let start = minus.span();
                let end = right.span();
                start.merge(&end)
            }
            ArithmeticOperationExpression::Positive { plus, right } => {
                let start = plus.span();
                let end = right.span();
                start.merge(&end)
            }
            ArithmeticOperationExpression::PreIncrement { increment, right } => {
                let start = increment.span();
                let end = right.span();
                start.merge(&end)
            }
            ArithmeticOperationExpression::PostIncrement { left, increment } => {
                let start = left.span();
                let end = increment.span();
                start.merge(&end)
            }
            ArithmeticOperationExpression::PreDecrement { decrement, right } => {
                let start = decrement.span();
                let end = right.span();
                start.merge(&end)
            }
            ArithmeticOperationExpression::PostDecrement { left, decrement } => {
                let start = left.span();
                let end = decrement.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for AssignmentOperationExpression {
    fn span(&self) -> Span {
        match self {
            AssignmentOperationExpression::Assign {
                left,
                equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            AssignmentOperationExpression::Addition {
                left,
                plus_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            AssignmentOperationExpression::Subtraction {
                left,
                minus_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            AssignmentOperationExpression::Multiplication {
                left,
                asterisk_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            AssignmentOperationExpression::Division {
                left,
                slash_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            AssignmentOperationExpression::Modulo {
                left,
                percent_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            AssignmentOperationExpression::Exponentiation {
                left,
                pow_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            AssignmentOperationExpression::Concat {
                left,
                dot_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            AssignmentOperationExpression::BitwiseAnd {
                left,
                ampersand_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            AssignmentOperationExpression::BitwiseOr {
                left,
                pipe_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            AssignmentOperationExpression::BitwiseXor {
                left,
                caret_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            AssignmentOperationExpression::LeftShift {
                left,
                left_shift_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            AssignmentOperationExpression::RightShift {
                left,
                right_shift_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            AssignmentOperationExpression::Coalesce {
                left,
                coalesce_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for BitwiseOperationExpression {
    fn span(&self) -> Span {
        match self {
            BitwiseOperationExpression::And { left, and, right } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            BitwiseOperationExpression::Or { left, or, right } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            BitwiseOperationExpression::Xor { left, xor, right } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            BitwiseOperationExpression::LeftShift {
                left,
                left_shift,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            BitwiseOperationExpression::RightShift {
                left,
                right_shift,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            BitwiseOperationExpression::Not { not, right } => {
                let start = not.span();
                let end = right.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for ComparisonOperationExpression {
    fn span(&self) -> Span {
        match self {
            ComparisonOperationExpression::Equal {
                left,
                double_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ComparisonOperationExpression::Identical {
                left,
                triple_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ComparisonOperationExpression::NotEqual {
                left,
                bang_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ComparisonOperationExpression::AngledNotEqual {
                left,
                angled_left_right,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ComparisonOperationExpression::NotIdentical {
                left,
                bang_double_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ComparisonOperationExpression::LessThan {
                left,
                less_than,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ComparisonOperationExpression::GreaterThan {
                left,
                greater_than,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ComparisonOperationExpression::LessThanOrEqual {
                left,
                less_than_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ComparisonOperationExpression::GreaterThanOrEqual {
                left,
                greater_than_equals,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            ComparisonOperationExpression::Spaceship {
                left,
                spaceship,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for LogicalOperationExpression {
    fn span(&self) -> Span {
        match self {
            LogicalOperationExpression::And {
                left,
                double_ampersand,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            LogicalOperationExpression::Or {
                left,
                double_pipe,
                right,
            } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            LogicalOperationExpression::Not { bang, right } => {
                let start = bang.span();
                let end = right.span();
                start.merge(&end)
            }
            LogicalOperationExpression::LogicalAnd { left, and, right } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            LogicalOperationExpression::LogicalOr { left, or, right } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
            LogicalOperationExpression::LogicalXor { left, xor, right } => {
                let start = left.span();
                let end = right.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for Name {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for NameKind {
    fn span(&self) -> Span {
        match self {
            NameKind::Special(inner) => inner.span(),
            NameKind::Unresolved(inner) => inner.span(),
            NameKind::Resolved(inner) => inner.span(),
        }
    }
}

impl Spanned for SpecialName {
    fn span(&self) -> Span {
        self.kind.span()
    }
}

impl Spanned for SpecialNameKind {
    fn span(&self) -> Span {
        match self {
            SpecialNameKind::Self_ => Span::default(),
            SpecialNameKind::Parent => Span::default(),
            SpecialNameKind::Static => Span::default(),
        }
    }
}

impl Spanned for UnresolvedName {
    fn span(&self) -> Span {
        Span::default()
    }
}

impl Spanned for ResolvedName {
    fn span(&self) -> Span {
        Span::default()
    }
}

impl Spanned for Property {
    fn span(&self) -> Span {
        let start = self.attributes.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for VariableProperty {
    fn span(&self) -> Span {
        let start = self.attributes.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for PropertyEntry {
    fn span(&self) -> Span {
        match self {
            PropertyEntry::Uninitialized { variable } => variable.span(),
            PropertyEntry::Initialized {
                variable,
                equals,
                value,
            } => {
                let start = variable.span();
                let end = value.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for TraitBody {
    fn span(&self) -> Span {
        let start = self.left_brace.span();
        let end = self.right_brace.span();
        start.merge(&end)
    }
}

impl Spanned for TraitStatement {
    fn span(&self) -> Span {
        let start = self.r#trait.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for TraitUsage {
    fn span(&self) -> Span {
        let start = self.r#use.span();
        let end = self.adaptations.span();
        start.merge(&end)
    }
}

impl Spanned for TraitUsageAdaptation {
    fn span(&self) -> Span {
        match self {
            TraitUsageAdaptation::Alias {
                r#trait,
                method,
                alias,
                visibility,
            } => {
                let start = r#trait.span();
                let end = visibility.span();
                start.merge(&end)
            }
            TraitUsageAdaptation::Visibility {
                r#trait,
                method,
                visibility,
            } => {
                let start = r#trait.span();
                let end = visibility.span();
                start.merge(&end)
            }
            TraitUsageAdaptation::Precedence {
                r#trait,
                method,
                insteadof,
            } => {
                let start = r#trait.span();
                let end = insteadof.span();
                start.merge(&end)
            }
        }
    }
}

impl Spanned for CatchType {
    fn span(&self) -> Span {
        match self {
            CatchType::Identifier { identifier } => identifier.span(),
            CatchType::Union { identifiers } => identifiers.span(),
        }
    }
}

impl Spanned for TryStatement {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.finally.span();
        start.merge(&end)
    }
}

impl Spanned for CatchBlock {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for FinallyBlock {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.body.span();
        start.merge(&end)
    }
}

impl Spanned for Variable {
    fn span(&self) -> Span {
        match self {
            Variable::SimpleVariable(inner) => inner.span(),
            Variable::VariableVariable(inner) => inner.span(),
            Variable::BracedVariableVariable(inner) => inner.span(),
        }
    }
}

impl Spanned for SimpleVariable {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for VariableVariable {
    fn span(&self) -> Span {
        self.span
    }
}

impl Spanned for BracedVariableVariable {
    fn span(&self) -> Span {
        let start = self.start.span();
        let end = self.end.span();
        start.merge(&end)
    }
}

impl Spanned for Ending {
    fn span(&self) -> Span {
        match self {
            Ending::Missing(inner) => inner.span(),
            Ending::Semicolon(inner) => inner.span(),
            Ending::CloseTag(inner) => inner.span(),
        }
    }
}

impl Spanned for StaticStatement {
    fn span(&self) -> Span {
        self.vars.span()
    }
}

impl Spanned for SwitchStatement {
    fn span(&self) -> Span {
        let start = self.switch.span();
        let end = self.cases.span();
        start.merge(&end)
    }
}

impl Spanned for EchoStatement {
    fn span(&self) -> Span {
        let start = self.echo.span();
        let end = self.ending.span();
        start.merge(&end)
    }
}

impl Spanned for ReturnStatement {
    fn span(&self) -> Span {
        let start = self.r#return.span();
        let end = self.ending.span();
        start.merge(&end)
    }
}

impl Spanned for UseStatement {
    fn span(&self) -> Span {
        let start = self.kind.span();
        let end = self.uses.span();
        start.merge(&end)
    }
}

impl Spanned for GroupUseStatement {
    fn span(&self) -> Span {
        let start = self.prefix.span();
        let end = self.uses.span();
        start.merge(&end)
    }
}

impl Spanned for HaltCompilerStatement {
    fn span(&self) -> Span {
        self.content.span()
    }
}

impl Spanned for StaticVar {
    fn span(&self) -> Span {
        let start = self.var.span();
        let end = self.default.span();
        start.merge(&end)
    }
}
